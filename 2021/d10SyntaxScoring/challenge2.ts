/** Autogenerated template. */

const closingCharsToOpeningCharsMap: { [key: string]: string } = {
  ")": "(",
  "]": "[",
  "}": "{",
  ">": "<",
};

const characterScoreMap: { [key: string]: number } = {
  "(": 1,
  "[": 2,
  "{": 3,
  "<": 4,
};

const openingChars = Object.values(closingCharsToOpeningCharsMap);

const isSeeminglyValid = (chunk: string) => {
  const stack = [];

  for (let i = 0; i < chunk.length; i++) {
    const character = chunk[i];

    if (openingChars.includes(character)) {
      stack.push(character);
    } else {
      const lastStackItem = stack[stack.length - 1];
      const expectedOpeningCharacter = closingCharsToOpeningCharsMap[character];
      if (lastStackItem === expectedOpeningCharacter) {
        stack.pop();
      } else {
        return false;
      }
    }
  }

  return true;
};

const getUnmatchedChars = (chunk: string): string[] => {
  const stack = [];

  for (let i = 0; i < chunk.length; i++) {
    const character = chunk[i];

    if (openingChars.includes(character)) {
      stack.push(character);
    } else {
      const lastStackItem = stack[stack.length - 1];
      const expectedOpeningCharacter = closingCharsToOpeningCharsMap[character];
      if (lastStackItem === expectedOpeningCharacter) {
        stack.pop();
      } else {
        return stack;
      }
    }
  }

  return stack;
};

const runSolution = (input: string[]): any => {
  /** Solution goes here */
  const unmatchedChars: number[] = input
    .filter(isSeeminglyValid)
    .map(getUnmatchedChars)
    .map((row) =>
      row
        .reverse()
        .reduce(
          (accumulator, current) =>
            accumulator * 5 + characterScoreMap[current],
          0
        )
    )
    .sort((a, b) => a - b);

  return unmatchedChars[Math.floor(unmatchedChars.length / 2)];
};

export default runSolution;
