/** Autogenerated template. */

const UNFLASHED_CELL_MARKER = 10;
const FLASHED_CELL_MARKER = 0;

const getUnflashedCells = (grid: number[][]): number[][] => {
  const unflashedCells: number[][] = [];

  for (let rowIdx = 0; rowIdx < grid.length; rowIdx++) {
    const row = grid[rowIdx];
    for (let colIdx = 0; colIdx < row.length; colIdx++) {
      const cellValue = row[colIdx];
      if (cellValue === UNFLASHED_CELL_MARKER) {
        unflashedCells.push([rowIdx, colIdx]);
      }
    }
  }

  return unflashedCells;
};

const isGridFullyFlashed = (inputGrid: number[][]): boolean => {
  for (const row of inputGrid) {
    if (row.includes(UNFLASHED_CELL_MARKER)) {
      return false;
    }
  }

  return true;
};

const normalizeFlashedAndUnflashedCells = (
  inputGrid: number[][]
): number[][] => {
  let grid = [...inputGrid];
  for (let rowIdx = 0; rowIdx < grid.length; rowIdx++) {
    for (let colIdx = 0; colIdx < grid[rowIdx].length; colIdx++) {
      if (grid[rowIdx][colIdx] === UNFLASHED_CELL_MARKER) {
        grid[rowIdx][colIdx] = FLASHED_CELL_MARKER;
      }
    }
  }

  return grid;
};

const incrementAdjacentCellPositions = (
  inputGrid: number[][],
  [rowIdx, colIdx]: number[],
  isFlashing: boolean = false
): number[][] => {
  let grid = [...inputGrid];
  const adjacentCellsPos = [];

  if (rowIdx > 0) {
    adjacentCellsPos.push([rowIdx - 1, colIdx]);
    if (colIdx > 0) {
      adjacentCellsPos.push([rowIdx - 1, colIdx - 1]);
    }
    if (colIdx < grid[rowIdx].length - 1) {
      adjacentCellsPos.push([rowIdx - 1, colIdx + 1]);
    }
  }

  if (rowIdx < grid.length - 1) {
    adjacentCellsPos.push([rowIdx + 1, colIdx]);
    if (colIdx > 0) {
      adjacentCellsPos.push([rowIdx + 1, colIdx - 1]);
    }
    if (colIdx < grid[rowIdx].length - 1) {
      adjacentCellsPos.push([rowIdx + 1, colIdx + 1]);
    }
  }

  if (colIdx > 0) {
    adjacentCellsPos.push([rowIdx, colIdx - 1]);
  }

  if (colIdx < grid[rowIdx].length - 1) {
    adjacentCellsPos.push([rowIdx, colIdx + 1]);
  }

  for (let i = 0; i < adjacentCellsPos.length; i++) {
    const cellPosition = adjacentCellsPos[i];
    grid = incrementGridValueAtPos(grid, cellPosition, isFlashing);
  }

  return grid;
};

const incrementGridValueAtPos = (
  inputGrid: number[][],
  [rowIdx, colIdx]: number[],
  isFlashing: boolean = false
): number[][] => {
  let grid = [...inputGrid];
  const cell = grid[rowIdx][colIdx];

  if (cell === FLASHED_CELL_MARKER && isFlashing) {
    return grid;
  }

  if (cell === UNFLASHED_CELL_MARKER) {
    return grid;
  }

  if (cell === 9) {
    grid[rowIdx][colIdx] = UNFLASHED_CELL_MARKER;
  } else if (cell !== undefined) {
    grid[rowIdx][colIdx]++;
  }

  return grid;
};

const step = (inputGrid: number[][]): number[][] => {
  let grid = [...inputGrid];
  for (let rowIdx = 0; rowIdx < grid.length; rowIdx++) {
    const row = grid[rowIdx];
    for (let colIdx = 0; colIdx < row.length; colIdx++) {
      grid = incrementGridValueAtPos(grid, [rowIdx, colIdx]);
    }
  }

  return grid;
};

const flash = (inputGrid: number[][]): number[][] => {
  let grid = [...inputGrid];

  while (!isGridFullyFlashed(grid)) {
    const unflashedCells = getUnflashedCells(grid);
    grid = normalizeFlashedAndUnflashedCells(grid);
    for (const cellPosition of unflashedCells) {
      grid = incrementAdjacentCellPositions(grid, cellPosition, true);
    }
  }

  return grid;
};

const areAllCellsFlashing = (inputGrid: number[][]): boolean =>
  inputGrid.every((row) => row.every((cell) => cell === FLASHED_CELL_MARKER));

const runSolution = (input: number[][]): any => {
  /** Solution goes here */
  let grid: number[][] = [...input];

  const numSteps = 500; // An arbitrary number of steps large enough that we might encounter a flash sync

  for (let i = 0; i < numSteps; i++) {
    grid = step(grid);
    grid = flash(grid);

    if (areAllCellsFlashing(grid)) {
      return i + 1;
    }
  }

  return "There was no synced flash within the test number of steps.";
};

export default runSolution;
