/** Autogenerated template. */

const foldPaper = (
  inputPaper: number[][],
  foldInstruction: string
): number[][] => {
  let paper = [...inputPaper];
  const [axis, position] = foldInstruction.split("=");
  const foldPosition = Number(position);

  if (axis === "y") {
    paper = paper.slice(0, foldPosition);

    const cutOffRows = inputPaper.slice(foldPosition + 1);
    for (let i = 0; i < cutOffRows.length; i++) {
      const correspondingPaperRow = paper[paper.length - 1 - i];

      if (correspondingPaperRow) {
        for (let j = 0; j < correspondingPaperRow.length; j++) {
          paper[paper.length - 1 - i][j] += cutOffRows[i][j];
        }
      }
    }
  } else {
    for (let i = 0; i < paper.length; i++) {
      const row = paper[i].slice(0, foldPosition);
      const sliceStartIdx = foldPosition + 1;
      const cutOffCols = paper[i].slice(
        sliceStartIdx,
        sliceStartIdx + row.length
      );

      for (let j = 0; j < cutOffCols.length; j++) {
        row[row.length - 1 - j] += cutOffCols[j];
      }

      paper[i] = row;
    }
  }

  return paper;
};

const constructPaper = (dotPositions: string[]): number[][] => {
  const gridSize = 1500;
  const paper = Array.from({ length: gridSize }).map((row) =>
    Array(gridSize).fill(0)
  );
  for (const dotPosition of dotPositions) {
    const [yPos, xPos] = dotPosition.split(",").map(Number);
    paper[xPos][yPos] += 1;
  }
  return paper;
};

const runSolution = (input: {
  foldInstructions: string[];
  dotPositions: string[];
}): any => {
  /** Solution goes here */
  let paper = constructPaper(input.dotPositions);

  paper = foldPaper(paper, input.foldInstructions[0]);

  return paper
    .map((row) => row.filter((x) => x > 0).length)
    .reduce((dotsCount, current) => dotsCount + current, 0);
};

export default runSolution;
